// Each #kernel tells which function to compile; you can have many kernels
//#pragma kernel FragmentBufferBuild
#pragma kernel SortFragments
#pragma kernel TileBufferBuild
#pragma kernel TileBufferSplat
#pragma kernel BlurTest

//#pragma enable_cbuffer

#define TILE_SIZE 16
#define TILE_MAX_FRAGMENTS 8192

//CBUFFER_START(TileSplatParams)
cbuffer TileSplatParams {
	// test if changing 2 uints to a unit2 will break anything
	// uint screenWidth;
	// uint screenHeight;
	uint2 numTiles;
	uint2 resolution;

	uint maxBlurRadiusCurrent;
};
//CBUFFER_END

struct FragmentData
{
	float3 color;
	float2 screenPosition;
	float psfIndex; // depth of some kind
	float blurRadius;
};

RWStructuredBuffer<FragmentData> fragmentBuffer;

RWStructuredBuffer<uint> tileFragmentCountBuffer;

struct SortIndex
{
	uint fragmentIndex;
	float depth; // uses "sort" depth which adds a term based on index to avoid Z-fighting
};

RWStructuredBuffer<SortIndex> tileSortBuffer;

Texture2D<float4> iColor;
RWTexture2D<float4> oColor;

// depth is stored in .x
Texture2D<float4> iDepth;

uint fragmentArrayIndex(const uint2 fragmentCoord)
{
	return fragmentCoord.y * resolution.x + fragmentCoord.x;
}

uint tileArrayIndex(const uint2 tileCoord)
{
	return (tileCoord.y * numTiles.x + tileCoord.x) * TILE_MAX_FRAGMENTS;
}

uint tileCountArrayIndex(const uint2 tileCoord)
{
	return tileCoord.y * numTiles.x + tileCoord.x;
}

bool isValidTileCoord(const uint2 tileCoord)
{
	return all(tileCoord >= uint2(0, 0)) && all(tileCoord < numTiles);
}

float3 sphericalCoordinates(const uint2 screenPosition, const float depth)
{
	// do something
}

float3 computePsfIndex(const uint2 screenPosition, const float depth)
{
	return depth;
}

// max radii for each color channel
float3 maxBlurRadii(float psfIndex)
{
	return 1;
}

float computeSortDepth(const uint2 screenPosition, const float depth)
{
	return depth;
}

// check if given fragmentCoord + blur overlaps with given tileCoord
bool overlapsTile(const uint2 tileCoord, const uint2 fragmentCoord, const float blurRadius)
{
	return true;
}

// unused currently
[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void FragmentBufferBuild(uint3 id : SV_DispatchThreadID)
{
	const uint2 fragmentCoord = id.xy;
	if (any(fragmentCoord >= resolution))
		return;
	const uint fragmentIndex = fragmentArrayIndex(fragmentCoord);

	const float3 color = iColor[fragmentCoord];
	const float depth = iDepth[fragmentCoord];

	FragmentData fragmentData;
	fragmentData.color = color;
	fragmentData.screenPosition = float2(fragmentCoord);
	fragmentData.psfIndex = computePsfIndex(fragmentCoord, depth);
	fragmentData.blurRadius = maxBlurRadii(fragmentData.psfIndex)[2];

	fragmentBuffer[fragmentIndex] = fragmentData;
}

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileBufferBuild(uint3 id : SV_DispatchThreadID)
{
	const uint2 fragmentCoord = id.xy;
	if (any(fragmentCoord >= resolution))
		return;
	const uint fragmentIndex = fragmentArrayIndex(fragmentCoord);

	const float3 color = iColor[fragmentCoord];
	const float depth = iDepth[fragmentCoord];

	FragmentData fragmentData;
	fragmentData.color = color;
	fragmentData.screenPosition = float2(fragmentCoord);
	fragmentData.psfIndex = computePsfIndex(fragmentCoord, depth);
	fragmentData.blurRadius = maxBlurRadii(fragmentData.psfIndex)[2];

	fragmentBuffer[fragmentIndex] = fragmentData;

//--------------------

	const uint2 tileCoord = id.xy / TILE_SIZE;
	const uint2 threadId = id.xy % TILE_SIZE;
	//const uint2 fragmentCoord = id.xy;

	//const uint fragmentIndex = fragmentArrayIndex(fragmentCoord);
	const uint tileIndex = tileArrayIndex(tileCoord);
	const uint countIndex = tileCountArrayIndex(tileCoord);

	//FragmentData fragmentData = fragmentBuffer[fragmentIndex];

	SortIndex sortIndex;
	sortIndex.fragmentIndex = fragmentIndex;
	sortIndex.depth = computeSortDepth(fragmentData.screenPosition, fragmentData.psfIndex);

	tileSortBuffer[tileIndex + fragmentIndex] = sortIndex;

	if (all(threadId == 0))
	{
		tileFragmentCountBuffer[countIndex] = TILE_SIZE * TILE_SIZE;
	}
}

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileBufferSplat(uint3 id : SV_DispatchThreadID)
{
	const uint2 tileCoord = id.xy / TILE_SIZE;
	const uint2 threadId = id.xy % TILE_SIZE;
	const uint2 fragmentCoord = id.xy;

	const uint fragmentIndex = fragmentArrayIndex(fragmentCoord);
	const uint countIndex = tileCountArrayIndex(tileCoord);

	const FragmentData fragmentData = fragmentBuffer[fragmentIndex];
	
	SortIndex sortIndex;
	sortIndex.fragmentIndex = fragmentIndex;
	sortIndex.depth = computeSortDepth(fragmentData.screenPosition, fragmentData.psfIndex);

	const int numTilesSplat = 1;

	for (int i = -numTilesSplat; i <= numTilesSplat; i++)
	{
		for (int j = -numTilesSplat; j <= numTilesSplat; j++)
		{
			const uint2 neighborOffset = uint2(i, j);
			const uint2 neighborTileCoord = tileCoord + neighborOffset;
			if (all(neighborOffset == uint2(0, 0))) continue;
			if (!isValidTileCoord(neighborTileCoord)) continue;
			if (!overlapsTile(neighborTileCoord, fragmentData.screenPosition, fragmentData.blurRadius)) continue;

			const uint neighborTileIndex = tileArrayIndex(neighborTileCoord);
			const uint neighborCountIndex = tileCountArrayIndex(neighborTileCoord);

			uint neighborFragmentCount;
			InterlockedAdd(tileFragmentCountBuffer[neighborCountIndex], 1, neighborFragmentCount);
			tileSortBuffer[neighborTileIndex + neighborFragmentCount] = sortIndex;
		}
	}
}

[numthreads(8,8,1)]
void BlurTest(uint3 id : SV_DispatchThreadID)
{
	uint texWidth;
	uint texHeight;
	iColor.GetDimensions(texWidth, texHeight);
	if (id.x >= texWidth || id.y >= texHeight)
		return;
	float4 color = float4(0.0, 0.0, 0.0, 1.0);
	uint cnt = 0;
	for (int i = -10; i <= 10; i++)
	{
		for (int j = -10; j <= 10; j++)
		{
			if (id.x + i >= 0 && id.x + i < texWidth && id.y + j >= 0 && id.y + j < texHeight) 
			{
				color += iColor[id.xy + int2(i, j)];
				cnt++;
			}
		}
	}
	color /= cnt;
	//color.x = _iDepth[id.xy].x;
	oColor[id.xy] = color;
}


#define MAX_FRAGMENTS_PER_TILE 1024

RWStructuredBuffer<uint> indices;
RWStructuredBuffer<float> depths;

groupshared uint fragmentIndices[MAX_FRAGMENTS_PER_TILE];
groupshared float fragmentDepths[MAX_FRAGMENTS_PER_TILE];

[numthreads(MAX_FRAGMENTS_PER_TILE,1,1)]
void SortFragments(uint3 id_in_tile : SV_DispatchThreadID) {
	uint id = id_in_tile.x;
	fragmentIndices[id] = indices[id];
	fragmentDepths[id] = depths[id];
	GroupMemoryBarrierWithGroupSync();

	for (int k = 2; k <= MAX_FRAGMENTS_PER_TILE; k *= 2) {
		for (int j = k / 2; j > 0; j /= 2) {
			uint i = id;
			uint l = i ^ j;
			if (l > i) {
				if (((i & k) == 0 && fragmentDepths[i] > fragmentDepths[l]) || ((i & k) != 0 && fragmentDepths[i] < fragmentDepths[l])) {
					float ftmp = fragmentDepths[i];
					fragmentDepths[i] = fragmentDepths[l];
					fragmentDepths[l] = ftmp;

					uint itmp = fragmentIndices[i];
					fragmentIndices[i] = fragmentIndices[l];
					fragmentIndices[l] = itmp;
				}
			}

			// roughly equivalent to __syncthreads(), explicitly fences over shared memory only
			GroupMemoryBarrierWithGroupSync();
		}
	}

	indices[id] = fragmentIndices[id];
	depths[id] = fragmentDepths[id];
}

struct PsfParam {
	uint minBlurRadius; // px
	uint maxBlurRadius; // px
	uint numPsfWeights;
	float blurRadiusDeg;
};

StructuredBuffer<float> psfWeights;
StructuredBuffer<PsfParam> psfParams;


struct CoordinatesIndices {
	uint2 fragmentCoord;
	uint2 tileId;
	uint2 threadId;
	uint threadIndex;
	uint arrayIndex;
	uint countArrayIndex;
	uint numTileFragments;
	uint groupSize;
	uint batchSize;
};



// Perform convolution
uint unpackBatchFragments(const int batchId) {

}

float3 samplePsf(uint2 fragmentCoord, FragmentData) {

}


void convolve() {

}

void convolveFragment() {

}

[numthreads(32, 32, 1)] // fix this
void Convolution(uint3 dispatchThreadID : SV_DispatchThreadID, uint3 localThreadID : SV_GroupThreadID)
{
	// define coordinates by calling DEFINE_COORDINATES_INDICES
	CoordinatesIndices coords = GetCoordinatesIndices(SV_DispatchThreadID, SV_GroupThreadID);

	// extract number of fragments to process via sTileParametersBuffer
	uint uiNumFragments = sTileParametersBuffer[coords.countArrayIndex].uiNumFragmentsTotal; //todo 

	// Number of batches to make
	uint numBatches = (uiNumFragments + coords.batchSize - 1) / coords.batchSize;

	// Init the PSF data
			// csoba is currently empty

	// for each batch
			// unpack batch fragments to shared mem
			// perform convolution
	for (int batchId = 0; batchId < numBatches; ++batchId) {

	}

	// ignore out of bound pixels

	// normalize

	// write out convolution result

}