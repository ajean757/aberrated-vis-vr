// Each #kernel tells which function to compile; you can have many kernels
//#pragma kernel FragmentBufferBuild
#pragma kernel TileBufferBuild
#pragma kernel TileBufferSplat
#pragma kernel SortFragments
#pragma kernel Convolve
#pragma kernel BlurTest

//#pragma enable_cbuffer

#define FLT_MAX 3.402823466e+38F

/* These must be synced with constants in the render pass */
#define TILE_SIZE 16
#define SHARED_ARRAY_SIZE 256 // TILE_SIZE * TILE_SIZE

#define TILE_MAX_FRAGMENTS 4096
#define SORT_GROUP_SIZE 1024

#define BOX_BLUR_RADIUS 4
#define BOX_BLUR_WEIGHT (1.0f / 81.0f) // 1 / (2 * BOX_BLUR_RADIUS + 1)^2

#define CEIL_DIV(x, y) ((x - 1) / y + 1)

//CBUFFER_START(TileSplatParams)
cbuffer TileSplatParams {
	uint2 numTiles;
	uint2 resolution;

	uint maxBlurRadiusCurrent;
};
//CBUFFER_END

struct FragmentData
{
	float3 color;
	float2 screenPosition;
	float psfIndex; // depth of some kind
	float blurRadius;
};

RWStructuredBuffer<FragmentData> fragmentBuffer;

RWStructuredBuffer<uint> tileFragmentCountBuffer; // num of fragments in each tile

struct SortIndex
{
	uint fragmentIndex;
	float depth; // uses "sort" depth which adds a term based on index to avoid Z-fighting
};

RWStructuredBuffer<SortIndex> tileSortBuffer;

Texture2D<float4> iColor;
RWTexture2D<float4> oColor;

// depth is stored in .x
Texture2D<float4> iDepth;

struct PsfParam {
	uint minBlurRadius; // px
	uint maxBlurRadius; // px
	uint numPsfWeights;
	float blurRadiusDeg;
};

StructuredBuffer<float> psfWeights;
StructuredBuffer<PsfParam> psfParams;

uint FragmentArrayIndex(const uint2 fragmentCoord)
{
	return fragmentCoord.y * resolution.x + fragmentCoord.x;
}

// Index for tileSortBuffer, first index of fragment in that tile
uint TileArrayIndex(const uint2 tileCoord) 
{
	return (tileCoord.y * numTiles.x + tileCoord.x) * TILE_MAX_FRAGMENTS;
}

// Index for tileFragmentCountBuffer, linearize 2d tile coord
uint TileCountArrayIndex(const uint2 tileCoord)
{
	return tileCoord.y * numTiles.x + tileCoord.x;
}

bool IsValidTileCoord(const uint2 tileCoord)
{
	return all(tileCoord >= uint2(0, 0)) && all(tileCoord < numTiles);
}

float3 SphericalCoordinates(const uint2 screenPosition, const float depth)
{
	
	// fragmentData.vPsfIndex = sphericalCoordinates(fragmentCoord, fragmentDepth);
	// 	vec3 sphericalCoordinatesOffAxis(const ivec2 screenPos, const float depth)
	// {
	// 	return convertSphericalCoordinates(screenToSphericalCoordinates(screenPos, sTiledSplatBlurData.vResolution, depth));
	// }
	// 	vec3 convertSphericalCoordinates(const vec3 sphericalCoords)
	// {
	// 	return vec3(convertIncidentAngles(sphericalCoords.xy), convertDepth(sphericalCoords.z));
	// }
	// // Converts the input incident angles to the appropriate representation for rendering
	// vec2 convertIncidentAngles(const vec2 anglesRad)
	// {
	// 	return clamp
	// 	(
	// 		degrees(anglesRad),
	// 		vec2(sTiledSplatBlurData.fHorizontalAnglesMin, sTiledSplatBlurData.fVerticalAnglesMin),
	// 		vec2(sTiledSplatBlurData.fHorizontalAnglesMax, sTiledSplatBlurData.fVerticalAnglesMax)
	// 	);
	// }
	// // Converts the input camera-space depth to the appropriate representation for rendering
	// float convertDepth(const float depth)
	// {
	// 	return max(depth + sTiledSplatBlurData.fDepthOffset, 1e-4);
	// }
	// // Returns the spherical coordinates of the input screen position
	// // Inputs:
	// // - screenPos: screen-space coordinates [0, resolution - 1]
	// // - depth: corresponding depth buffer value
	// //
	// // Returns:
	// // - result[0:1]: horizontal and vertical angles, in radians
	// // - result[2]:   distance, in meters
	// vec3 screenToSphericalCoordinates(const ivec2 screenPos, const ivec2 resolution, const float depth)
	// {

	// 	const vec3 camPos = reconstructPositionCS(screenPos, resolution, depth); // Convert from clip-space to camera space

	// 	const vec2 angles = vec2(atan2(camPos.x, -camPos.z), atan2(camPos.y, length(camPos.zx))); // azimuth and elevation terms
	// 	const float radius = meters(length(camPos));
	// 	return vec3(angles, radius);
	// }

	// // Returns the spherical coordinates of the input screen position
	// vec3 screenToSphericalCoordinates(const ivec2 screenPos, const float depth)
	// {
	//     return screenToSphericalCoordinates(screenPos, ivec2(sRenderData.vResolution), depth);
	// }

}

float ComputePsfIndex(const uint2 screenPosition, const float depth)
{
	return depth;
}

// max radii for each color channel
float3 MaxBlurRadii(float psfIndex)
{
	return BOX_BLUR_RADIUS;
}

float ComputeSortDepth(const uint2 screenPosition, const float depth)
{
	return depth;
}

// check if given fragmentCoord + blur overlaps with given tileCoord
bool OverlapsTile(const uint2 tileCoord, const int2 fragmentCoord, const float blurRadius)
{
	// The two corners of the neighboring tile.
	const int2 tileMin = tileCoord * TILE_SIZE;
	const int2 tileMax = tileMin + (TILE_SIZE - 1);

	// Distance of the center fragment to the edges of the neighboring tile
	const int2 distToMin = abs(tileMin - fragmentCoord);
	const int2 distToMax = abs(tileMax - fragmentCoord);
	
	// Evaluate the side and corner conditions
	return
		// Vertical neighbors
		(fragmentCoord.x >= tileMin.x && fragmentCoord.x <= tileMax.x && (distToMin.y <= blurRadius || distToMax.y <= blurRadius)) ||

		// Horizontal neighbors
		(fragmentCoord.y >= tileMin.y && fragmentCoord.y <= tileMax.y && (distToMin.x <= blurRadius || distToMax.x <= blurRadius)) ||

		// Oblique neighbors
		(distToMin.x <= blurRadius && distToMin.y <= blurRadius) ||
		(distToMin.x <= blurRadius && distToMax.y <= blurRadius) ||
		(distToMax.x <= blurRadius && distToMin.y <= blurRadius) ||
		(distToMax.x <= blurRadius && distToMax.y <= blurRadius);
}

// fragmentData is being splatted to fragmentCoord
float3 SamplePsf(const uint2 fragmentCoord, const FragmentData fragmentData)
{
	int2 delta = (int2)fragmentCoord - (int2)fragmentData.screenPosition;
	return all(delta >= -BOX_BLUR_RADIUS && delta <= BOX_BLUR_RADIUS) ? BOX_BLUR_WEIGHT : 0;
}

// unused currently
// [numthreads(TILE_SIZE, TILE_SIZE, 1)]
// void FragmentBufferBuild(uint3 id : SV_DispatchThreadID)
// {
// 	const uint2 fragmentCoord = id.xy;
// 	if (any(fragmentCoord >= resolution))
// 		return;
// 	const uint fragmentIndex = FragmentArrayIndex(fragmentCoord);

// 	const float3 color = iColor[fragmentCoord].xyz;
// 	const float depth = iDepth[fragmentCoord].x;

// 	FragmentData fragmentData;
// 	fragmentData.color = color;
// 	fragmentData.screenPosition = float2(fragmentCoord);
// 	fragmentData.psfIndex = ComputePsfIndex(fragmentCoord, depth);
// 	fragmentData.blurRadius = MaxBlurRadii(fragmentData.psfIndex).z;

// 	fragmentBuffer[fragmentIndex] = fragmentData;
// }

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileBufferBuild(uint3 id : SV_DispatchThreadID)
{
	const uint2 fragmentCoord = id.xy;
	if (any(fragmentCoord >= resolution))
		return;
	const uint fragmentIndex = FragmentArrayIndex(fragmentCoord);

	const float3 color = iColor[fragmentCoord].xyz;
	const float depth = iDepth[fragmentCoord].x;

	FragmentData fragmentData;
	fragmentData.color = color;
	fragmentData.screenPosition = float2(fragmentCoord);
	fragmentData.psfIndex = ComputePsfIndex(fragmentCoord, depth);
	fragmentData.blurRadius = MaxBlurRadii(fragmentData.psfIndex).z;

	fragmentBuffer[fragmentIndex] = fragmentData;

//--------------------

	const uint2 tileCoord = id.xy / TILE_SIZE;
	const uint2 threadId = id.xy % TILE_SIZE;
	//const uint2 fragmentCoord = id.xy;

	//const uint fragmentIndex = FragmentArrayIndex(fragmentCoord);
	const uint tileIndex = TileArrayIndex(tileCoord);
	const uint countIndex = TileCountArrayIndex(tileCoord);

	//FragmentData fragmentData = fragmentBuffer[fragmentIndex];

	SortIndex sortIndex;
	sortIndex.fragmentIndex = fragmentIndex;
	sortIndex.depth = ComputeSortDepth(fragmentData.screenPosition, fragmentData.psfIndex);

	const uint2 size = min(resolution - tileCoord * TILE_SIZE, uint2(TILE_SIZE, TILE_SIZE));

	//tileSortBuffer[tileIndex + fragmentIndex] = sortIndex;
	tileSortBuffer[tileIndex + threadId.y * size.x + threadId.x] = sortIndex;

	if (all(threadId == 0))
	{
		tileFragmentCountBuffer[countIndex] = size.x * size.y;
	}
}

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileBufferSplat(uint3 id : SV_DispatchThreadID)
{
	const uint2 tileCoord = id.xy / TILE_SIZE;
	const uint2 threadId = id.xy % TILE_SIZE;
	const uint2 fragmentCoord = id.xy;

	if (any(fragmentCoord >= resolution))
		return;

	const uint fragmentIndex = FragmentArrayIndex(fragmentCoord);
	const uint countIndex = TileCountArrayIndex(tileCoord);

	const FragmentData fragmentData = fragmentBuffer[fragmentIndex];
	
	SortIndex sortIndex;
	sortIndex.fragmentIndex = fragmentIndex;
	sortIndex.depth = ComputeSortDepth(fragmentData.screenPosition, fragmentData.psfIndex);

	const int numTilesSplat = CEIL_DIV(maxBlurRadiusCurrent, TILE_SIZE);

	for (int i = -numTilesSplat; i <= numTilesSplat; i++)
	{
		for (int j = -numTilesSplat; j <= numTilesSplat; j++)
		{
			const uint2 neighborOffset = uint2(i, j);
			const uint2 neighborTileCoord = tileCoord + neighborOffset;
			if (all(neighborOffset == uint2(0, 0))) continue;
			if (!IsValidTileCoord(neighborTileCoord)) continue;
			if (!OverlapsTile(neighborTileCoord, fragmentData.screenPosition, fragmentData.blurRadius)) continue;

			const uint neighborTileIndex = TileArrayIndex(neighborTileCoord);
			const uint neighborCountIndex = TileCountArrayIndex(neighborTileCoord);

			uint neighborFragmentCount;
			InterlockedAdd(tileFragmentCountBuffer[neighborCountIndex], 1, neighborFragmentCount);
			if (neighborFragmentCount < TILE_MAX_FRAGMENTS)
				tileSortBuffer[neighborTileIndex + neighborFragmentCount] = sortIndex;
		}
	}

	if (all(threadId == 0))
	{
		if (tileFragmentCountBuffer[countIndex] > TILE_MAX_FRAGMENTS)
			tileFragmentCountBuffer[countIndex] = TILE_MAX_FRAGMENTS;
	}
}

[numthreads(8,8,1)]
void BlurTest(uint3 id : SV_DispatchThreadID)
{
	uint texWidth;
	uint texHeight;
	iColor.GetDimensions(texWidth, texHeight);
	if (id.x >= texWidth || id.y >= texHeight)
		return;
	float4 color = float4(0.0, 0.0, 0.0, 1.0);
	uint cnt = 0;
	for (int i = -10; i <= 10; i++)
	{
		for (int j = -10; j <= 10; j++)
		{
			if (id.x + i >= 0 && id.x + i < texWidth && id.y + j >= 0 && id.y + j < texHeight) 
			{
				color += iColor[id.xy + int2(i, j)];
				cnt++;
			}
		}
	}
	color /= cnt;
	//color.x = _iDepth[id.xy].x;
	oColor[id.xy] = color;
}

//RWStructuredBuffer<uint> indices;
//RWStructuredBuffer<float> depths;

groupshared uint fragmentIndices[SORT_GROUP_SIZE];
groupshared float fragmentDepths[SORT_GROUP_SIZE];

[numthreads(SORT_GROUP_SIZE,1,1)]
void SortFragments(uint3 id_dispatch : SV_DispatchThreadID) {
	uint threadId = id_dispatch.x;
	uint2 tileCoord = id_dispatch.yz;
	
	const uint countIndex = TileCountArrayIndex(tileCoord);
	const uint tileIndex = TileArrayIndex(tileCoord);

	const uint fragmentCount = tileFragmentCountBuffer[countIndex];

	/* Presort */
	SortIndex sortIndex = tileSortBuffer[tileIndex + threadId];
	if (threadId < fragmentCount)
	{
		fragmentIndices[threadId] = sortIndex.fragmentIndex;
		fragmentDepths[threadId] = sortIndex.depth;
	}
	else
	{
		//fragmentIndices[threadId] = -1;
		fragmentDepths[threadId] = FLT_MAX;
	}
	GroupMemoryBarrierWithGroupSync();

	for (uint k = 2; k <= SORT_GROUP_SIZE; k *= 2) {
		for (uint j = k / 2; j > 0; j /= 2) {
			uint i = threadId;
			uint l = i ^ j;
			if (l > i) {
				if (((i & k) == 0 && fragmentDepths[i] > fragmentDepths[l]) || ((i & k) != 0 && fragmentDepths[i] < fragmentDepths[l])) {
					float ftmp = fragmentDepths[i];
					fragmentDepths[i] = fragmentDepths[l];
					fragmentDepths[l] = ftmp;

					uint itmp = fragmentIndices[i];
					fragmentIndices[i] = fragmentIndices[l];
					fragmentIndices[l] = itmp;
				}
			}

			// roughly equivalent to __syncthreads(), explicitly fences over shared memory only
			GroupMemoryBarrierWithGroupSync();
		}
	}



	if (threadId < fragmentCount)
	{
		sortIndex.fragmentIndex = fragmentIndices[threadId];
		sortIndex.depth = fragmentDepths[threadId];
		tileSortBuffer[tileIndex + threadId] = sortIndex;
	}
}

groupshared FragmentData tileFragments[SHARED_ARRAY_SIZE];
groupshared uint fragmentCount;

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void Convolve(uint3 id : SV_DispatchThreadID)
{
	const uint2 tileCoord = id.xy / TILE_SIZE;
	const uint2 threadId = id.xy % TILE_SIZE;
	const uint2 fragmentCoord = id.xy;

	const bool invalid = any(fragmentCoord >= resolution);

	const uint fragmentIndex = FragmentArrayIndex(fragmentCoord);
	const uint countIndex = TileCountArrayIndex(tileCoord);
	const uint tileIndex = TileArrayIndex(tileCoord);

	//const uint fragmentCount = tileFragmentCountBuffer[countIndex];

	const uint threadIndex = threadId.y * TILE_SIZE + threadId.x;

	if (threadIndex == 0)
		fragmentCount = tileFragmentCountBuffer[countIndex];
	GroupMemoryBarrierWithGroupSync();

	/* Front to back alpha blending using premultiplied alpha */
	float3 result = float3(0, 0, 0);
	float3 alpha = float3(0, 0, 0);

	/* Groupshare ver. */
	for (uint batchId = 0; batchId < CEIL_DIV(fragmentCount, SHARED_ARRAY_SIZE); batchId++)
	{
		uint offset = batchId * SHARED_ARRAY_SIZE + threadIndex;
		SortIndex sortIndex = tileSortBuffer[tileIndex + offset];
		if (offset < fragmentCount)
			tileFragments[threadIndex] = fragmentBuffer[sortIndex.fragmentIndex];
		GroupMemoryBarrierWithGroupSync();

		if (!invalid)
		{
			uint cnt = min(fragmentCount - batchId * SHARED_ARRAY_SIZE, SHARED_ARRAY_SIZE);
			for (uint i = 0; i < cnt; i++)
			{
				FragmentData fragmentData = tileFragments[i];
				float3 weight = SamplePsf(fragmentCoord, fragmentData);

				result += weight * fragmentData.color;

				// result += (1.0 - alpha) * weight * fragmentData.color;
				// alpha = weight + (1.0 - weight) * alpha;
			}
		}
		GroupMemoryBarrierWithGroupSync();
	}

	/* No groupshare ver. */
	// for (uint i = 0; i < fragmentCount; i++)
	// {
	// 	SortIndex sortIndex = tileSortBuffer[tileIndex + i];
	// 	FragmentData fragmentData = fragmentBuffer[sortIndex.fragmentIndex];
	// 	float3 weight = SamplePsf(fragmentCoord, fragmentData);

	// 	result += weight * fragmentData.color;

	// 	// result += (1.0 - alpha) * weight * fragmentData.color;
	// 	// alpha = weight + (1.0 - weight) * alpha;
	// }
	
	oColor[fragmentCoord] = float4(result, 1);
}
