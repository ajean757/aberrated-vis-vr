// Each #kernel tells which function to compile; you can have many kernels
//#pragma kernel FragmentBufferBuild
#pragma kernel TileBufferBuild
#pragma kernel TileBufferSplat
#pragma kernel SortFragments
#pragma kernel BlurTest

//#pragma enable_cbuffer

#define TILE_SIZE 16
#define TILE_MAX_FRAGMENTS 8192

//CBUFFER_START(TileSplatParams)
cbuffer TileSplatParams {
	uint2 numTiles;
	uint2 resolution;

	uint maxBlurRadiusCurrent;
};
//CBUFFER_END

struct FragmentData
{
	float3 color;
	float2 screenPosition;
	float psfIndex; // depth of some kind
	float blurRadius;
};

RWStructuredBuffer<FragmentData> fragmentBuffer;

RWStructuredBuffer<uint> tileFragmentCountBuffer;

struct SortIndex
{
	uint fragmentIndex;
	float depth; // uses "sort" depth which adds a term based on index to avoid Z-fighting
};

RWStructuredBuffer<SortIndex> tileSortBuffer;

Texture2D<float4> iColor;
RWTexture2D<float4> oColor;

// depth is stored in .x
Texture2D<float4> iDepth;

uint FragmentArrayIndex(const uint2 fragmentCoord)
{
	return fragmentCoord.y * resolution.x + fragmentCoord.x;
}

// Index for tileSortBuffer
uint TileArrayIndex(const uint2 tileCoord)
{
	return (tileCoord.y * numTiles.x + tileCoord.x) * TILE_MAX_FRAGMENTS;
}

// Index for tileFragmentCountBuffer
uint TileCountArrayIndex(const uint2 tileCoord)
{
	return tileCoord.y * numTiles.x + tileCoord.x;
}

bool IsValidTileCoord(const uint2 tileCoord)
{
	return all(tileCoord >= uint2(0, 0)) && all(tileCoord < numTiles);
}

float3 SphericalCoordinates(const uint2 screenPosition, const float depth)
{
	// do something
}

float ComputePsfIndex(const uint2 screenPosition, const float depth)
{
	return depth;
}

// max radii for each color channel
float3 MaxBlurRadii(float psfIndex)
{
	return 1;
}

float ComputeSortDepth(const uint2 screenPosition, const float depth)
{
	return depth;
}

// check if given fragmentCoord + blur overlaps with given tileCoord
bool OverlapsTile(const uint2 tileCoord, const uint2 fragmentCoord, const float blurRadius)
{
	return true;
}

// unused currently
// [numthreads(TILE_SIZE, TILE_SIZE, 1)]
// void FragmentBufferBuild(uint3 id : SV_DispatchThreadID)
// {
// 	const uint2 fragmentCoord = id.xy;
// 	if (any(fragmentCoord >= resolution))
// 		return;
// 	const uint fragmentIndex = FragmentArrayIndex(fragmentCoord);

// 	const float3 color = iColor[fragmentCoord].xyz;
// 	const float depth = iDepth[fragmentCoord].x;

// 	FragmentData fragmentData;
// 	fragmentData.color = color;
// 	fragmentData.screenPosition = float2(fragmentCoord);
// 	fragmentData.psfIndex = ComputePsfIndex(fragmentCoord, depth);
// 	fragmentData.blurRadius = MaxBlurRadii(fragmentData.psfIndex).z;

// 	fragmentBuffer[fragmentIndex] = fragmentData;
// }

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileBufferBuild(uint3 id : SV_DispatchThreadID)
{
	const uint2 fragmentCoord = id.xy;
	if (any(fragmentCoord >= resolution))
		return;
	const uint fragmentIndex = FragmentArrayIndex(fragmentCoord);

	const float3 color = iColor[fragmentCoord].xyz;
	const float depth = iDepth[fragmentCoord].x;

	FragmentData fragmentData;
	fragmentData.color = color;
	fragmentData.screenPosition = float2(fragmentCoord);
	fragmentData.psfIndex = ComputePsfIndex(fragmentCoord, depth);
	fragmentData.blurRadius = MaxBlurRadii(fragmentData.psfIndex).z;

	fragmentBuffer[fragmentIndex] = fragmentData;

//--------------------

	const uint2 tileCoord = id.xy / TILE_SIZE;
	const uint2 threadId = id.xy % TILE_SIZE;
	//const uint2 fragmentCoord = id.xy;

	//const uint fragmentIndex = FragmentArrayIndex(fragmentCoord);
	const uint tileIndex = TileArrayIndex(tileCoord);
	const uint countIndex = TileCountArrayIndex(tileCoord);

	//FragmentData fragmentData = fragmentBuffer[fragmentIndex];

	SortIndex sortIndex;
	sortIndex.fragmentIndex = fragmentIndex;
	sortIndex.depth = ComputeSortDepth(fragmentData.screenPosition, fragmentData.psfIndex);

	tileSortBuffer[tileIndex + fragmentIndex] = sortIndex;

	if (all(threadId == 0))
	{
		tileFragmentCountBuffer[countIndex] = TILE_SIZE * TILE_SIZE;
	}
}

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileBufferSplat(uint3 id : SV_DispatchThreadID)
{
	const uint2 tileCoord = id.xy / TILE_SIZE;
	const uint2 threadId = id.xy % TILE_SIZE;
	const uint2 fragmentCoord = id.xy;

	const uint fragmentIndex = FragmentArrayIndex(fragmentCoord);
	const uint countIndex = TileCountArrayIndex(tileCoord);

	const FragmentData fragmentData = fragmentBuffer[fragmentIndex];
	
	SortIndex sortIndex;
	sortIndex.fragmentIndex = fragmentIndex;
	sortIndex.depth = ComputeSortDepth(fragmentData.screenPosition, fragmentData.psfIndex);

	const int numTilesSplat = 1;

	for (int i = -numTilesSplat; i <= numTilesSplat; i++)
	{
		for (int j = -numTilesSplat; j <= numTilesSplat; j++)
		{
			const uint2 neighborOffset = uint2(i, j);
			const uint2 neighborTileCoord = tileCoord + neighborOffset;
			if (all(neighborOffset == uint2(0, 0))) continue;
			if (!IsValidTileCoord(neighborTileCoord)) continue;
			if (!OverlapsTile(neighborTileCoord, fragmentData.screenPosition, fragmentData.blurRadius)) continue;

			const uint neighborTileIndex = TileArrayIndex(neighborTileCoord);
			const uint neighborCountIndex = TileCountArrayIndex(neighborTileCoord);

			uint neighborFragmentCount;
			InterlockedAdd(tileFragmentCountBuffer[neighborCountIndex], 1, neighborFragmentCount);
			tileSortBuffer[neighborTileIndex + neighborFragmentCount] = sortIndex;
		}
	}
}

[numthreads(8,8,1)]
void BlurTest(uint3 id : SV_DispatchThreadID)
{
	uint texWidth;
	uint texHeight;
	iColor.GetDimensions(texWidth, texHeight);
	if (id.x >= texWidth || id.y >= texHeight)
		return;
	float4 color = float4(0.0, 0.0, 0.0, 1.0);
	uint cnt = 0;
	for (int i = -10; i <= 10; i++)
	{
		for (int j = -10; j <= 10; j++)
		{
			if (id.x + i >= 0 && id.x + i < texWidth && id.y + j >= 0 && id.y + j < texHeight) 
			{
				color += iColor[id.xy + int2(i, j)];
				cnt++;
			}
		}
	}
	color /= cnt;
	//color.x = _iDepth[id.xy].x;
	oColor[id.xy] = color;
}


#define MAX_FRAGMENTS_PER_TILE 1024

RWStructuredBuffer<uint> indices;
RWStructuredBuffer<float> depths;

groupshared uint fragmentIndices[MAX_FRAGMENTS_PER_TILE];
groupshared float fragmentDepths[MAX_FRAGMENTS_PER_TILE];

[numthreads(MAX_FRAGMENTS_PER_TILE,1,1)]
void SortFragments(uint3 id_in_tile : SV_DispatchThreadID) {
	uint id = id_in_tile.x;
	fragmentIndices[id] = indices[id];
	fragmentDepths[id] = depths[id];
	GroupMemoryBarrierWithGroupSync();

	for (uint k = 2; k <= MAX_FRAGMENTS_PER_TILE; k *= 2) {
		for (uint j = k / 2; j > 0; j /= 2) {
			uint i = id;
			uint l = i ^ j;
			if (l > i) {
				if (((i & k) == 0 && fragmentDepths[i] > fragmentDepths[l]) || ((i & k) != 0 && fragmentDepths[i] < fragmentDepths[l])) {
					float ftmp = fragmentDepths[i];
					fragmentDepths[i] = fragmentDepths[l];
					fragmentDepths[l] = ftmp;

					uint itmp = fragmentIndices[i];
					fragmentIndices[i] = fragmentIndices[l];
					fragmentIndices[l] = itmp;
				}
			}

			// roughly equivalent to __syncthreads(), explicitly fences over shared memory only
			GroupMemoryBarrierWithGroupSync();
		}
	}

	indices[id] = fragmentIndices[id];
	depths[id] = fragmentDepths[id];
}

struct PsfParam {
	uint minBlurRadius; // px
	uint maxBlurRadius; // px
	uint numPsfWeights;
	float blurRadiusDeg;
};

StructuredBuffer<float> psfWeights;
StructuredBuffer<PsfParam> psfParams;


struct CoordinatesIndices {
	uint2 fragmentCoord;
	uint2 tileId;
	uint2 threadId;
	uint threadIndex;
	uint arrayIndex;
	uint countArrayIndex;
	uint numTileFragments;
	uint groupSize;
	uint batchSize;
};



// // Perform convolution
// uint unpackBatchFragments(const int batchId) {

// }

// float3 samplePsf(uint2 fragmentCoord, FragmentData) {

// }


// void convolve() {

// }

// void convolveFragment() {

// }

// [numthreads(32, 32, 1)] // fix this
// void Convolution(uint3 dispatchThreadID : SV_DispatchThreadID, uint3 localThreadID : SV_GroupThreadID)
// {
// 	// define coordinates by calling DEFINE_COORDINATES_INDICES
// 	CoordinatesIndices coords = GetCoordinatesIndices(SV_DispatchThreadID, SV_GroupThreadID);

// 	// extract number of fragments to process via sTileParametersBuffer
// 	uint uiNumFragments = sTileParametersBuffer[coords.countArrayIndex].uiNumFragmentsTotal; //todo 

// 	// Number of batches to make
// 	uint numBatches = (uiNumFragments + coords.batchSize - 1) / coords.batchSize;

// 	// Init the PSF data
// 			// csoba is currently empty

// 	// for each batch
// 			// unpack batch fragments to shared mem
// 			// perform convolution
// 	for (int batchId = 0; batchId < numBatches; ++batchId) {

// 	}

// 	// ignore out of bound pixels

// 	// normalize

// 	// write out convolution result

// }